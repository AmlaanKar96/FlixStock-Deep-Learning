# -*- coding: utf-8 -*-
"""Multibranch_Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C_QacU3rEWnsgWGABxww6ZVlsPrg0lDq
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
from PIL import Image
import os
import pickle
import glob
import random
import itertools
import copy
import math
from skimage import color
from sklearn.metrics import accuracy_score
from torch.utils.data import Dataset
from torchvision import datasets
from torchvision.transforms import ToTensor
import torchvision.transforms as transforms
from torch.utils.data import DataLoader
from sklearn.metrics import classification_report
from sklearn.neighbors import KNeighborsClassifier
import torch
import torch.optim as optim
import torch.nn as nn
import torch.nn.functional as F
from sklearn.metrics import confusion_matrix
import seaborn as sns
import csv
import pandas as pd
from sklearn.model_selection import train_test_split

parser = argparse.ArgumentParser(description='PyTorch Training')
parser.add_argument('data', metavar='DIR', default='/content/drive/My Drive/Colab Notebooks/FlixStock/classification-assignment.zip (Unzipped Files)/classification-assignment/images/')
parser.add_argument('attributes', default='/content/drive/My Drive/Colab Notebooks/FlixStock/classification-assignment.zip (Unzipped Files)/classification-assignment/attributes.csv')
args = parser.parse_args()

filenames_train=glob.glob(args.data+'*')
filenames_train=sorted(filenames_train)
filenames_train=sorted(filenames_train,key=len)

len(filenames_train)

df=pd.read_csv(args.attributes)
df

df=df.values
len(df)

df_dict,dtset,labels,dtset_dict={},[],[],{}
for i in df:
    df_dict[i[0]]=i
for i in filenames_train:
    ret=i.split('/')[-1]
    try:
        ret1=df_dict[ret]
        try:
            ret1=int(df_dict[ret][1])
            ret2=int(df_dict[ret][2])
            ret3=int(df_dict[ret][3])
            dtset.append(df_dict[ret][0])
            labels.append([df_dict[ret][1],df_dict[ret][2],df_dict[ret][3]])
            try:
                ret4=dtset_dict[ret1]
            except:
                dtset_dict[ret1]={}
            try:
                ret4=dtset_dict[ret1][ret2]
            except:
                dtset_dict[ret1][ret2]={}
            try:
                dtset_dict[ret1][ret2][ret3]+=1
            except:
                dtset_dict[ret1][ret2][ret3]=1
        except:
            pass
    except:
        pass

dtset_dict

df_dict,dtset,labels,dtset_dict={},[],[],{}
for i in df:
    df_dict[i[0]]=i
for i in filenames_train:
    ret=i.split('/')[-1]
    try:
        ret1=df_dict[ret]
        try:
            ret1=df_dict[ret][1]
            ret2=df_dict[ret][2]
            ret3=df_dict[ret][3]
            try:
                try:
                    ret1=int(ret1)
                except:
                    try:
                        if int(ret2)!=3:
                            ret1=6
                            ret3=9
                        else:
                            try:
                                if int(ret3)!=9:
                                    ret1=6
                                else:
                                    continue
                            except:
                                continue
                    except:
                        try:
                            if int(ret3)!=9:
                                ret1=6
                                ret2=3
                            else:
                                continue
                        except:
                            continue
                ret4=dtset_dict[ret1]
            except:
                dtset_dict[ret1]={}
            try:
                try:
                    ret2=int(ret2)
                except:
                    try:
                        if int(ret1)!=6:
                            ret2=3
                            ret3=9
                        else:
                            try:
                                if int(ret3)!=9:
                                    ret2=3
                                else:
                                    continue
                            except:
                                continue
                    except:
                        continue
                ret4=dtset_dict[ret1][ret2]
            except:
                dtset_dict[ret1][ret2]={}
            try:
                try:
                    ret3=int(ret3)
                except:
                    try:
                        if int(ret1)!=6:
                            ret3=9
                            ret2=3
                        else:
                            try:
                                if int(ret2)!=3:
                                    ret3=9
                                else:
                                    continue
                            except:
                                continue
                    except:
                        continue
                dtset_dict[ret1][ret2][ret3]+=1
            except:
                dtset_dict[ret1][ret2][ret3]=1
            dtset.append(df_dict[ret][0])
            labels.append([ret1,ret2,ret3])
        except:
            pass
    except:
        pass

dtset_dict

X_train, X_test, y_train, y_test = train_test_split(dtset, labels, test_size=0.1, random_state=42)

class FlixStockDataset(Dataset):
    def __init__(self, filenames, label_dict, transform=None):#, target_transform=None):
        self.transform = transform
        # self.target_transform = target_transform
        self.filenames=filenames
        self.label_dict=label_dict

    def __len__(self):
        return len(self.filenames)

    def __getitem__(self, idx):
        image = Image.open('/content/drive/My Drive/Colab Notebooks/FlixStock/classification-assignment.zip (Unzipped Files)/classification-assignment/images/'+self.filenames[idx])
        image=image.convert('RGB')
        label=self.label_dict[self.filenames[idx]][1:]
        if self.transform:
            sample = self.transform(image)
        label = np.array([label])
        label = label.astype('float').reshape(-1, 3)
        dict_data = {
            'img': sample,
            'labels': {
                'pattern': label[0][0],
                'sleeve_length': label[0][1],
                'neck_type': label[0][2]
            }
        }
        return dict_data, idx

transform = transforms.Compose([transforms.Resize((300,225)),
                                transforms.ToTensor(),
                                transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                                  std=[0.229, 0.224, 0.225])])

transform_train = transforms.Compose([
    transforms.Resize((300,225)),
    transforms.RandomHorizontalFlip(),
    transforms.ColorJitter(brightness=.5, hue=.5, saturation=.5, contrast=.5),
    transforms.RandomRotation(20),
    transforms.RandomAffine(degrees=20, translate=(0.1, 0.1), scale=(0.8, 1.2),
                            shear=None, fill=(255, 255, 255)),
    transforms.RandomPerspective(distortion_scale=0.5),
    transforms.GaussianBlur(5),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                              std=[0.229, 0.224, 0.225])
])


transform_label = transforms.Compose([transforms.ToTensor()])

train_dataset = FlixStockDataset(X_train, y_train, transform=transform_train)#, target_transform=transform_label)
test_dataset = FlixStockDataset(X_test, y_test, transform=transform)#, target_transform=transform_label)

train_loader = DataLoader(train_dataset, batch_size=16,
                        shuffle=True, num_workers=0)
test_loader = DataLoader(test_dataset, batch_size=16,
                        shuffle=False, num_workers=0)

class_weights={'pattern':[1/i for i in np.bincount(np.array(y_train,dtype='int64')[:,0])], 'sleeve_length':[1/i for i in np.bincount(np.array(y_train,dtype='int64')[:,1])], 'neck_type':[1/i for i in np.bincount(np.array(y_train,dtype='int64')[:,2])]}

import torchvision.models as models
class MultiOutputModel(nn.Module):
    def __init__(self, patterns, sleeve_types, neck_types):
        super().__init__()
        # self.base_model = models.vgg16_bn(pretrained=True)
        self.conv1 = nn.Conv2d(3, 6, 5)
        self.pool = nn.MaxPool2d(2, 2)
        self.conv2 = nn.Conv2d(6, 16, 5)
        self.pattern = nn.Sequential(
            nn.Dropout(p=0.2),
            nn.Linear(in_features=61056, out_features=1000),
            nn.Dropout(p=0.2),
            # nn.Linear(in_features=6000, out_features=1000),
            nn.Linear(in_features=1000, out_features=patterns)
        )
        self.sleeve_length = nn.Sequential(
            nn.Dropout(p=0.2),
            nn.Linear(in_features=61056, out_features=1000),
            nn.Dropout(p=0.2),
            # nn.Linear(in_features=6000, out_features=1000),
            nn.Linear(in_features=1000, out_features=sleeve_types)
        )
        self.neck_type = nn.Sequential(
            nn.Dropout(p=0.2),
            nn.Linear(in_features=61056, out_features=1000),
            nn.Dropout(p=0.2),
            # nn.Linear(in_features=6000, out_features=1000),
            nn.Linear(in_features=1000, out_features=neck_types)
        )
    def forward(self, x):
        # for param in self.base_model.features.parameters():
        #     param.require_grad = False
        # print(x.shape)
        x = self.pool(F.tanh(self.conv1(x)))
        x = self.pool(F.tanh(self.conv2(x)))
        # print(x.shape)
        # x = self.pool(x)
        x = torch.flatten(x, start_dim=1)
        print(self.pattern(x).shape)
        return {
            'pattern': self.pattern(x),
            'sleeve_length': self.sleeve_length(x),
            'neck_type': self.neck_type(x)
        }


    def get_loss(self, net_output, ground_truth, class_weights):#gamma=2, alpha=0.25):
        pattern_loss = F.cross_entropy(net_output['pattern'], ground_truth['pattern'].long(), torch.FloatTensor(class_weights['pattern']))
        sleeve_length_loss = F.cross_entropy(net_output['sleeve_length'], ground_truth['sleeve_length'].long(), torch.FloatTensor(class_weights['sleeve_length']))
        neck_type_loss = F.cross_entropy(net_output['neck_type'], ground_truth['neck_type'].long(), torch.FloatTensor(class_weights['neck_type']))
        # focal_loss1 = (alpha * (1-torch.exp(-pattern_loss))**gamma * pattern_loss).mean()
        # focal_loss2 = (alpha * (1-torch.exp(-sleeve_length_loss))**gamma * sleeve_length_loss).mean()
        # focal_loss3 = (alpha * (1-torch.exp(-neck_type_loss))**gamma * neck_type_loss).mean()
        loss = pattern_loss + sleeve_length_loss + neck_type_loss
        return loss, {'pattern': pattern_loss, 'sleeve_length': sleeve_length_loss, 'neck_type': neck_type_loss}

N_epochs = 50
batch_size = 16
 
model = MultiOutputModel(patterns=7, sleeve_types=4, neck_types=10)
optimizer = torch.optim.Adam(model.parameters())
# criterion = nn.BCEWithLogitsLoss()

from sklearn.metrics import confusion_matrix
import pandas as pd
import seaborn as sns
max_acc1,max_acc2,max_acc3 = 0,0,0
for epoch in range(10):
    running_loss = 0.0
    for i, data in enumerate(train_loader, 0):
        img_dict, index = data
        optimizer.zero_grad()
        outputs = model(img_dict['img'])
        loss, loss_dict = model.get_loss(outputs, img_dict['labels'])
        loss.backward()
        # loss_dict['sleeve_length'].backward()
        # loss_dict['neck_type'].backward()
        optimizer.step()
        running_loss += loss.item()
    print('Epoch[%d] loss: %.3f' % (epoch + 1, running_loss))

    correct1, correct2, correct3 = 0, 0, 0
    total1, total2, total3 = 0, 0, 0
    pred_patt,lab_patt=[],[]
    pred_sleeve,lab_sleeve=[],[]
    pred_neck,lab_neck=[],[]
    with torch.no_grad():
        for data in test_loader:
            img_dict, index = data
            outputs = model(img_dict['img'])
            _, predicted_pattern = torch.max(outputs['pattern'].data, 1)
            _, predicted_sleeve_type = torch.max(outputs['sleeve_length'].data, 1)
            _, predicted_neck_type = torch.max(outputs['neck_type'].data, 1)
            total1 += img_dict['labels']['pattern'].size(0)
            total2 += img_dict['labels']['sleeve_length'].size(0)
            total3 += img_dict['labels']['neck_type'].size(0)
            correct1 += (predicted_pattern == img_dict['labels']['pattern']).sum().item()
            correct2 += (predicted_sleeve_type == img_dict['labels']['sleeve_length']).sum().item()
            correct3 += (predicted_neck_type == img_dict['labels']['neck_type']).sum().item()
            pred_patt.extend([i for i in predicted_pattern])
            lab_patt.extend([int(i) for i in img_dict['labels']['pattern']])
            pred_sleeve.extend([i for i in predicted_sleeve_type])
            lab_sleeve.extend([int(i) for i in img_dict['labels']['sleeve_length']])
            pred_neck.extend([i for i in predicted_neck_type])
            lab_neck.extend([int(i) for i in img_dict['labels']['neck_type']])
    print('Accuracy of the network on the test images (pattern): %.2d %%' % (100 * correct1 / total1))
    print('Accuracy of the network on the test images (sleeve_type): %.2d %%' % (100 * correct2 / total2))
    print('Accuracy of the network on the test images (neck_type): %.2d %%' % (100 * correct3 / total3))
    print(np.bincount(pred_patt))
    print(np.bincount(lab_patt))
    cm = confusion_matrix(lab_patt, pred_patt)
    sns.heatmap(cm,annot=True)
    plt.show()
    print(np.bincount(pred_sleeve))
    print(np.bincount(lab_sleeve))
    cm = confusion_matrix(lab_sleeve, pred_sleeve)
    sns.heatmap(cm,annot=True)
    plt.show()
    print(np.bincount(pred_neck))
    print(np.bincount(lab_neck))
    cm = confusion_matrix(lab_neck, pred_neck)
    sns.heatmap(cm,annot=True)
    plt.show()
    correct11, correct21, correct31 = 0, 0, 0
    total11, total21, total31 = 0, 0, 0
    with torch.no_grad():
        for data in train_loader:
            img_dict, index = data
            outputs = model(img_dict['img'])
            _, predicted_pattern = torch.max(outputs['pattern'].data, 1)
            _, predicted_sleeve_type = torch.max(outputs['sleeve_length'].data, 1)
            _, predicted_neck_type = torch.max(outputs['neck_type'].data, 1)
            total11 += img_dict['labels']['pattern'].size(0)
            total21 += img_dict['labels']['sleeve_length'].size(0)
            total31 += img_dict['labels']['neck_type'].size(0)
            correct11 += (predicted_pattern == img_dict['labels']['pattern']).sum().item()
            correct21 += (predicted_sleeve_type == img_dict['labels']['sleeve_length']).sum().item()
            correct31 += (predicted_neck_type == img_dict['labels']['neck_type']).sum().item()
    print('Accuracy of the network on the train images (pattern): %.2d %%' % (100 * correct11 / total11))
    print('Accuracy of the network on the train images (sleeve_type): %.2d %%' % (100 * correct21 / total21))
    print('Accuracy of the network on the train images (neck_type): %.2d %%' % (100 * correct31 / total31))
    if ((100 * correct1 / total1) > max_acc1 and (100 * correct11 / total11) - (100 * correct1 / total1) <= 20) or ((100 * correct2 / total2) > max_acc2 and (100 * correct21 / total21) - (100 * correct2 / total2) <= 20) or ((100 * correct3 / total3) > max_acc3 and (100 * correct31 / total31) - (100 * correct3 / total3) <= 20):
        max_acc1=(100 * correct1 / total1)
        max_acc2=(100 * correct2 / total2)
        max_acc3=(100 * correct3 / total3)
        torch.save(model.state_dict(), '/content/drive/My Drive/Colab Notebooks/FlixStock/classification-assignment.zip (Unzipped Files)/classification-assignment/Multibranch.pth')

